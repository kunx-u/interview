# Vue3 组合式 API 八股文

1. 通过 ref 函数封装的数据是什么对象?数据类型是?想获取封装后实现可响应式的数据应该注意什么?
   + RefImpl 引用实现对象
   + Ref 在 ts 中需要导入 import { type Ref } from 'vue'
   + 在脚本中获取数据需要通过.value 获取,在模板中直接可以使用,因为会自动解包
2. 通过 reactive 封装数据要注意什么?想获取封装后实现可响应式的数据应该注意什么?
   + reactive 只能封装复杂类型无法封装基本类型,封装之后是一个代理对象 Proxy,reactive 可以直接获取数据不需要通过.value,但是进行如下两个操作时会丢失可响应式
     + 重复赋值
     + 解构赋值
3. 如果使用 watch 侦听一个使用 ref 封装的复杂类型需要注意什么?
      + 如果要侦听这个类型的所有属性，则要开启深度侦听deep：true
      + 如果要侦听某一属性，watch(()=>复杂类型.要侦听的属性,(newVal,oldVal)=>{},{})
4. 如果使用 watch 则侦听时需要操作 DOM 应该注意什么?
      + 要等待页面更新之后再执行侦听器，flush： 'post'，否则可能导致侦听器执行过快，侦听的值  是页面DOM未更新前的数据
5. watchEffect侦听器 watch侦听器 computed 计算属性的使用场合?
      + computed计算属性注重的是由依赖数据最终计算出来返回的值，如果关注的是结果则用计算属性
      + 侦听器注重的是回调过程，需要根据响应式状态的变更，注重回调的过程则使用监听器
        + 如果有多个依赖数据则使用watchEffect，消除手动维护依赖列表的负担
        +  如果只有单一依赖数据则使用watch即可
6. 请列举一种 reactive 丢失可响应式的情况,如何解决
      + 重复赋值
        + 直接在reactive中再嵌套一个对象，赋值时将值赋给里面那层对象
        + 解构赋值
          + 解构赋值时用toRefs（）函数，将解构的reactive封装的可响应式对象内的所有属性转换为ref，或用toRef（）函数将该对象内某个属性转换为ref封装的RefImpl（引用实现对象
7. toRef toRefs unref isRef isProxy isReactive的作用
      + toRef:将一个对象内的某个属性转换为ref封装的RefImpl
      + toRefs：将一个对象内所有属性转换为ref封装
      + unref：内部如果是ref封装的则返回.value，不是则返回原来的值
      + isRef：判断是否是ref封装的RefImpl对象
      + isReactive：判断是否是可响应式的对象或者数组
8. Vue3生命周期的钩子函数的执行时机
      + onBeforeMount：初始化数据准备好，但模板未加载
      + onMounted：初始化数据准备好，模板加载好，数据挂载完毕
      + onBeforeUpdate：初始化数据改变时执行，此时初始化数据更新完毕但页面未更新，新的数据未挂载
      + onUpdated：初始化数据改变时执行，此时初始化数据更新完毕，页面也更新完毕，新的数据已经挂载
      + onBeforeUnMount：组件即将被销毁，初始化的数据和模板一切正常，此时清除缓存、停止网络请求，解除订阅
      + onUnMounted：组件已经销毁，初始化的数据和模板都不存在了
9. 为什么要使用 nextTick 
      + 在Vue中数据的更新和模板的更新时机不同，所有脚本执行完毕之后才会更新模板，所以可能会遇见数据已经更新但模板还未更新的情况，用nextTick可以确保在模板更新后执行之后的脚本

