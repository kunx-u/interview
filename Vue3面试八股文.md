# Vue3 面试八股文

1. 什么是单向绑定,什么是双向绑定
   + 单向绑定(只读):修改data中初始化的数据,则页面模板中的数据随之发生更改,这称之为单向绑定,又叫这个数据实现了可响应式,大胡子表达式和指令元素都支持单向绑定
   + 双向绑定(可写):修改模板中的数据,则管理模板的 Vue 实例的中 data 随之发生更改,则称之为双向绑定,v-model 自带双向绑定功能,其它数据如果想实现双向绑定功能,则必须使用计算属性

2. Vue 模板如何防止网络 XSS 攻击
    + 禁止在使用 v-html 时插入动作 

3. Vue3 如何进行样式渲染
    + 绑定 class
        + <tagName :class="初始化的值" />
          + 初始化的值对应 class 类名
        + <tagName :class="{类名:初始化的值,类名:初始化的值,}">
          + 初始化的值为真则类名存在 为假不存在
        + <tagName :class="['类名','类名','类名']" />
    + 绑定 style
        + <tagName :style="初始化的值" />
          + 初始化的值对应样式值
        + <tagName :style="{样式名:样式值,样式名:样式值}"  />

4. 函数 计算属性 侦听器有什么不同?使用场合是?
    + 函数
        + 一般绑定事件或者被直接调用,函数没有缓存机制,只要被调用就会执行, 函数仅仅支持单向绑定功能(只读),没有双向绑定功能(不可写),函数体内部可以书写异步代码
        + Vue3中 v-model 后面不能直接调用函数,因为不支持双向绑定(不可写)

    + 计算属性
        + 就是一个属性,不会传递值,也没有括号,是由它依赖的属性计算而来,只要依赖的属性发生变动,则计算属性重新执行,重新计算新的数据,只要依赖的属性没有变化,则计算属性根本不会再次执行,因为计算属性存在缓存机制,直接调用缓存中的数据 
        + 计算属性在书写 set 之后则可以实现双向绑定功能(可写)
        + 由于计算属性中的单向绑定必须书写 return 语句,因此,不能在计算属性中书写异步代码(return相当于同步,异步和同步出现在同一场合异步根本不会执行)
    
    + 侦听器
        + 一般不考虑单双向绑定,侦听器侦听哪个值,只要这个值发生变化,则侦听器执行,如果书写 immediate,则侦听器立即执行一次
        + 侦听器默认只能侦听基本数据类型,如果要侦听复杂类型,则必须开启深度侦听,deep:true
        + 侦听器内部不需要强制书写 return,因此可以发送异步

5. 条件渲染 v-if 和 v-show 的区别
   + v-if
     + 后面如果是真值,则元素显示,假值元素隐藏,底层不渲染可以取反,切换消耗较大,适用于不频繁切换的场合
   + v-show
     + 后面如果是真值,则元素显示,假值元素隐藏,底层依然渲染只不过添加了一个 display:none 的行内式 可以取反初始载入消耗较大,之后切换消耗较小,适合频繁切换的场合
   + v-else-if v-else
     + 以上两个指令是 Vue2.4 添加 专门用来搭配 v-if组成流程控制,不能与 v-show 连用,必须紧邻

6. 如何使用事件原型获取元素节点 
   + event.target

7. 简述你使用过的事件修饰符
   + .stop:解决冒泡问题
   + .once:激活一次性事件
   + .prevent:屏蔽元素固有的动作,例如表单 连接提交
   + .native:给组件添加原生事件
   + @keyup.键位名:监听键位的激发
   + @keydown.tab:监听 tab 键激发

8. Vue如何进行列表渲染(迭代数组和迭代对象)
   + v-for="(alias,index) in 数组"
   + v-for="(value,name,index) in 对象"
   + 注意存在主键则 :key="主键" 没有主键则 :key="index" 

9.  简述你所使用过的指令元素 
    + v-once:一次性插值绑定,之后失去绑定功能
    + v-html:向元素中插入超文本,注意!为了防止网络 XSS 攻击,禁止插入脚本
    + v-text:向元素中插入文本
    + v-model:使用在表单项中,支持双向绑定
        + v-model.trim:双向绑定数据,去掉字符串两侧空格
        + v-model.number:双向绑定数据,同时转换为 number,注意如果无法转换,则不转换
        + v-model.lazy:点击回车才会激活双向绑定功能
    + v-bind:语法糖:,绑定元素的属性
    + v-on:语法糖@,绑定事件
        + @事件.once
        + @事件.stop
        + @事件.prevent
        + @事件.native
        + @keyup.键位名
        + @keydown.tab
    + v-for:迭代数据
    + v-if:后面如果为真,则元素显示,为假,元素不显示,底层不渲染
    + v-else-if:搭配 v-if 使用必须紧邻
    + v-else:搭配 v-if 使用必须紧邻
    + v-show:后面如果为真,则元素显示,为假,元素不显示,底层依然渲染,只不过添加了display:none;css行内式
    + v-pre:提示 Vue 实例不解析
    + v-cloak:解决闪现问题
    + v-slot:父子组件传值时传递模板使用,是插槽的另外一种书写方式   

10. v-if 和 v-for 能够同时使用吗?解决方案是?
    + Vue2
      + 不推荐将v-for和v-if添加在同一个元素上,因为v-for比v-if优先级高，所以使用的话，每次v-for都会执行v-if,造成不必要的计算，影响性能，尤其是当之需要渲染很小一部分的时候。 当你需要进行同步指令的时候,尽量使用计算属性，先将v-if 不需要的值先过滤掉。
      + 解决方案 1 使用计算属性先进行过滤操作
        ```html
        <div v-for="alias in 计算属性"></div>
        ```
      + 解决方案 2 
        + <div v-for="alias in 循环体"><template v-if="判断"></template></div>
    + Vue3中 v-if 优先级 比 v-for 高,可以同时使用,但是在 v-if 中,慎重使用 v-for的别名,因为 v-for 还未执行,根本没有别名会报错因此依然推荐以下两个方案
        + v-for 与 v-if 不放置在一个元素中 v-for 嵌套 v-if
        + 使用计算属性

11. Vue2中对象和数组如何实现可响应式
      + 对象
        + this.$set() 
        + this.$delete
        + Vue.set()
        + Vue.delete()
      + 数组
        + push() unshift() shift() pop() sort() reverse() splice()
      + Vue3 底层是使用的 ES6 中反射,没有以上所有限制,怎么写实现了可响应式

12. 在模块化开发中如何使用外部依赖

      + import 别名 from '依赖' 在每个组件中导入外部依赖

      + 在 main.js 中

          ```js
          import 别名 from '依赖'
          
          Vue.prototype.属性名 = 别名
          //则可以在Vue 实例或者组件实例中直接通过 this.属性名 获取
          ```

13. 为什么 Vue 实例中data 是个对象而组件中 data 是个函数返回对象

      + 因为组件是⽤来复⽤的，且 JS ⾥对象是引⽤关系，如果组件中 data 是⼀个对象，那么这样作⽤域没有 隔离，⼦组件中的 data 属性值会相互影响，如果组件中 data 选项是⼀个函数，那么每个实例可以维护⼀份被返回对象的独⽴的拷⻉，组件实例之间 的 data 属性值不会互相影响；⽽ new Vue 的实例，是不会被复⽤的，因此不存在引⽤对象的问题。

14. 如何使用懒加载加载路由组件

      ```js
      const routes = [
          {
              path:'拦截哈希',
              component:()=>import('组件地址')
          }
      ]
      ```

15. 如何让CSS只在当前组件中起作⽤?

      + 在组件中的style标签前⾯加上scoped属性

16. this.$nextTick() 的作用

      + 立即执行当次操作 DOM 的语句,否则执行顺序不是自上而下

17. 请简述 Vue2 生命周期钩子函数的作用

      + 见课件 md 文件

18. Vue2 组件如何进行传值

      + props父子传值
          + 父组件 <子组件 :自定义属性="传递的值" >
          + props:['自定义属性']
          + props:{自定义属性:数据类型}
          + props:{自定义属性:{type:数据类型,required:true}}
      + $emit 子父传值
          + this.$emit('父组件自定义动作','传递的值')
      + slot 插槽分发
          + <模板 slot="插槽名">
          + <template v-slot:插槽名><要传递的模板></template>

19. $route和$router的区别

     + 是 VueRouter 提供的内置对象
     + $router是VueRouter的实例，在script标签中想要导航到不同的URL,使⽤$router.push,可以激活哈希,进行路由组件得切换
     + $route为当前router跳转对象。⾥⾯可以获取当前路由的name,path,query,parmas等,这些参数可以获取路由的信息,传递的值









